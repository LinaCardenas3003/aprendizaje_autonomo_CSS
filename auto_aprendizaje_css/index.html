<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aprendizaje Autónomo CSS</title>
  <link rel="stylesheet" href="css/estilos.css">
</head>

<body>

  <header>
    <h1>Aprendizaje Autónomo CSS</h1>
  </header>

  <section>
    <h1>¿Qué es un selector CSS?</h1>
    <p>Los selectores de CSS son una parte fundamental en la aplicación de estilos en páginas web. Constituyen herramientas esenciales que permiten seleccionar y definir cómo se aplicarán reglas de estilo a elementos específicos de una página. Para comprender mejor este concepto, es importante conocer los distintos tipos de selectores y cómo combinarlos. Un selector de CSS es, en esencia, un código que nos permite especificar qué elemento o elementos deseamos afectar con estilos particulares.</p>
    <hr>

    <h1>Selectores CSS básicos</h1>

    <h3>Seleccionar por etiquetas</h3>
    <p><strong>Selector: </strong>div<br>
      <strong>Descripción: </strong>Seleccionamos por etiqueta. Aplicamos estilos a todas las etiquetas que coincidan.<br>
      <strong>Ejemplo 1: </strong> todos los elementos que sean etiquetas HTML "strong" se visualizarán de color azul.<br>
      <strong>Ejemplo 2: </strong>Se le indicará al navegador que aplique un color de fondo azul a todas las etiquetas "div" encontradas en la página. La sección en la que se ha colocado div se denomina selector.
    </p>
    <div>
      <p>Este es un párrafo dentro de un div. El fondo de todos los div es AZUL y la letra sera BLANCA</p>
    </div>
    <img src="images/imagen1.jpeg" alt="" width="300">
    <hr>

    <h3>Seleccionar por ID (únicos)</h3>
    <p><strong>Selector: </strong>#page<strong><br>
      Descripción: </strong>Seleccionamos por ID. Aplicamos estilos al elemento que tenga ese id. Debería ser un único elemento.
    </p>
    <div id="ejemplo3">
      <p>Este es un parrafo dentro de un div con un id="ejemplo3". El fondo de este es ROJO</p>
    </div>
    <div id="ejemplo4">
      <p>Este es un parrafo dentro de un div con un id="ejemplo4". El fondo de este es NEGRO</p>
    </div>
    <img src="images/imagen2.jpeg" alt="" width="300">
    <hr>

    <h3>Seleccionar por clases</h3>
    <p><strong>Selector: </strong>.primary<strong><br>
      Descripción: </strong>Aplicamos estilos a los elementos que tengan dicha class. La diferencia principal respecto a los id es que las clases no necesitan ser únicas, sino que pueden repetirse a lo largo del documento HTML.
    </p>
    <div class="segundo_div">
      <strong>Ejemplo 5: </strong> Este div tendra un fondo rosa y letra negra su clase es "segundo_div"<br>
      <strong>Ejemplo 6: </strong> La opcion "1-2-3" son de color turquesa comparten una misma clase llamada "opcion".<br>
      <strong>Ejemplo 7: </strong> La opcion "Volver" es de color naranja su clase es diferente se llama "back"
      <p>Seleccione una opción:</p>
      <button class="opcion">Opción 1</button>
      <button class="opcion">Opción 2</button>
      <button class="opcion">Opción 3</button>
      <button class="back">Volver</button>
      <p class="ejemplo8">Este es un parrafo con la clase "ejemplo8" su color es marron tiene tamaño y estilo diferente.</p>
    </div>
    <img src="images/imagen3.jpeg" alt="" width="300">
    <hr>

    <h3>Selecciones mixtas</h3>
    <p><strong>Selector: </strong>button.primary<strong><br>
      Descripción: </strong>Mixto. Seleccionamos por múltiples criterios. En este caso, por elemento y por clase. es viable emplear múltiples clases en un solo elemento HTML, simplemente separándolas por espacios dentro del atributo class.<br>
      <strong>Ejemplo 9:  </strong> El primer boton o "Botón principal" como se observa tiene 3 clases y al combinar esas clases en el selector CSS "button.classic.primary.large" se aplica un estilo solo cuando el botón tiene todas esas clases al mismo tiempo. Lo mismo sucede con las casillas la primera tiene una clase llamada "casilla amarilla" y la segunda "casilla roja"
    </p>
    <button class="classic primary large">Botón Principal</button>
    <button class="classic secondary large">Botón Secundario</button>
    <button class="classic primary small">Botón Extra</button>
    
    <div class="casilla amarilla">
      <h2>Casilla Amarilla</h2>
      <p>Esta casilla tiene un fondo amarillo.</p>
    </div>
    
    <div class="casilla roja">
      <h2>Casilla Roja</h2>
      <p>Esta casilla tiene un fondo rojo.</p>
    </div>
    <img src="images/imagen4.jpeg" alt="" width="300">
  </section>
  <hr>

  <section>
    <h1>¿Qué son los atributos CSS?</h1>
    <p>En algunos casos puede que no tengamos clases ni id establecidas, y nos interese dar estilo por otros atributos.</p>
    <strong>Ejemplo 10: </strong>Al botón desactivado y al parrafo les pongo un atributo disabled. En el CSS pongo "button[disabled]" este selecciona solo los botones con el atributo "disabled" por otro lado al poner solo "[disabled]" solo selecciona cualquier elemento con el atributo "disabled <br>
    <button>Botón activo</button>
    <button disabled>Botón desactivado</button>
    <p disabled>parrafo del ejemplo al tener el atributo disabled </p>
    <img src="images/imagen5.jpeg" alt="" width="400">
    <p>Sin embargo, no todo resulta tan sencillo como el ejemplo anterior. Existen diversas maneras de emplear los atributos en CSS, algunas de ellas son muy potentes y flexibles. Estas se basan en un concepto denominado expresiones regulares,aunque no se ajustan estrictamente a la definición de expresiones regulares.</p>
    <img src="images/atributos.jpeg" alt="" width="600">

    <!-- Básicos -->
    <strong>[href]:</strong> Todos los enlaces < a > con href serán fucsia.
    <a href="http://127.0.0.1:5500/auto_aprendizaje_css/index.html#top">Enlace con href</a><br>

    <strong>href="#top": </strong>Si el enlace tiene exactamente href="#top", el texto será rojo.
    <a href="#top">Ir arriba</a>

    <p class="miclase"><strong>[class~="miclase"]: </strong>Los elementos con la clase "miclase" tendrán fondo amarillo y padding.</p>
    
    <p lang="ess-MX"><strong>[lang|="es"]: </strong> Si el atributo lang empieza con ess, el texto será verde e itálico. Este párrafo tiene un atributo "es-MX."</p>

    <!-- Avanzados -->
    <strong>[href^="https://"]: </strong> Los enlaces que empiezan con https:// tendrán un subrayado azul grueso.
    <a href="https://ejemplo.com">Enlace seguro.</a><br>

    <strong>[href$=".pdf"]: </strong> Si el enlace termina en .pdf, el texto será naranja.
    <a href="documento.pdf">Descargar PDF</a><br>

    <strong>[href*="miclase"]: </strong>  Si el href contiene la palabra miclase, tendrá un fondo turquesa.
    <a href="https://ejemplo.com/miclase">Enlace con miclase en el href</a> 
    <hr>

    <h3>Atributo con valor exacto</h3>
    <p>La potencia de los atributos CSS es que podemos indicar el valor exacto que deben tener para que sean seleccionados. Para ello, simplemente utilizamos el símbolo = y escribimos el texto entre comillas dobles: a[rel="nofollow"]</p>
    <a href="https://ejemplo.com" rel="nofollow">Enlace no seguido</a> <!-- Será afectado por CSS -->
    <a href="https://ejemplo.com" rel="noopener">Enlace seguro</a> <!-- No será afectado -->
    <a href="https://ejemplo.com" rel="nofollow noo">Enlace combinado</a> <!-- No será afectado porque el valor no es exactamente "nofollow" -->
    <p>Este ejemplo selecciona los enlaces <a> que tienen un atributo rel establecido a nofollow y le pone fondo rojo y letra blanca. </p>
    <img src="images/imagen6.jpeg" alt="" width="500">
    <img src="images/imagen7.jpeg" alt="" width="300">
    <hr>
    
    <h3>Atributo con lista de palabras</h3>
    <p data-mood="feliz relajado">Estoy tranquilo y feliz</p>  <!-- Se verá con fondo verde -->
    <p data-mood="triste">Hoy no es mi mejor día</p>  <!-- No se verá afectado -->
    <p data-mood="feliz emocionado">¡Qué gran día!</p>  <!-- Se verá con fondo verde -->
    <p data-mood="relajado">Descansando un poco</p>  <!-- No se verá afectado -->
    <p>[data-mood~="feliz"] selecciona solo los elementos donde la palabra "feliz" está en la lista del atributo data-mood. Si el atributo tiene feliz en su lista (como feliz relajado o feliz emocionado), se aplicará el estilo.</p>
    <img src="images/imagen8.jpeg" alt="" width="300">
    <img src="images/imagen9.jpeg" alt="" width="300">
    <hr>

    <h3>Atributo con lista compuesta</h3>
    <p lang="esi-MX">Este texto está en español de México.</p>  <!-- Se verá con fondo rojo -->
    <p lang="esi-CO">Este texto está en español de Colombia.</p>  <!-- Se verá con fondo rojo -->
    <p lang="en-US">This text is in English (USA).</p>  <!-- No se verá afectado -->
    <p>[lang|="esi"] selecciona los elementos cuyo atributo lang comienza con esi- (ejemplo: esi-MX, esi-CO). Los textos en español tendrán fondo rojo, texto verde y padding.</p>
    <img src="images/imagen10.jpeg" alt="" width="300">
    <img src="images/imagen11.jpeg" alt="" width="300">
    <hr>

    <div class="otro ejemplo">
      <h3>Comienzo de un atributo</h3>
      <p>Los atributos CSS permiten seleccionar elementos HTML dependiendo de si empiezan (o acaban) por el valor indicado.</p>
      
      <strong>a[href]::after </strong>Aplica a todos los enlaces < a > con href, mostrando su URL después del texto.<br>
      <strong>a[href^="http://"]::after </strong>Aplica solo a los enlaces que comienzan con "http://", agregando una advertencia de "Página no segura" en rojo.<br>
      <strong>a[href^="ftp://"]::after </strong>Aplica solo a los enlaces que comienzan con "ftp://", agregando una advertencia de "Descarga desde FTP" en azul.<br>
      <a href="http://ejemplo.com">Visitar sitio no seguro </a><br>  <!-- Mostrará advertencia -->
      <a href="https://seguro.com">Visitar sitio seguro </a><br>  <!-- No mostrará advertencia -->
      <a href="ftp://servidor.com">Descargar desde FTP </a><br>  <!-- Mostrará advertencia especial -->
      <p>Este método es útil para alertar sobre sitios inseguros, mejorar la accesibilidad y proporcionar información adicional sobre enlaces sin modificar el HTML.</p>
    </div>
    <img src="images/imagen12.jpeg" alt="" width="400">
    <hr>

    <div class="otro ejemplo">
      <h3>Final de un atributo</h3>
      <strong>a[href]::before </strong>Agrega un icono genérico antes de todos los enlaces.<br>
      <strong>a[href$=".pdf"]::before </strong>Si el enlace termina en ".pdf", se cambia el icono a uno específico de PDF.<br>
      <a href="documento.pdf">Descargar PDF</a><br>
      <a href="imagen.jpg">Ver Imagen</a><br>
      <a href="video.mp4">Reproducir Video</a><br>
      <a href="reporte.pdf">Reporte en PDF</a>
      <p>Este método es útil para identificar tipos de archivos antes de hacer clic en un enlace, ayudando a la accesibilidad y la usabilidad del sitio web.</p>
    </div><br>
    <img src="images/imagen13.jpeg" alt="" width="400"> 
    <hr>

    <h3>Atributo contiene texto</h3>
    <strong>a[href*="mipagina"] </strong>Aplica estilos a cualquier enlace < a > cuyo href contenga "mipagina" en cualquier parte del enlace. Los enlaces que contienen "mipagina" tendrán un fondo naranja y el texto en azul para destacarlos.<br>
    <a href="https://mipagina.com">Visitar Mi Página</a><br>
    <a href="https://otraweb.com/mipagina">Sección en Otra Web</a><br>
    <a href="https://ejemplo.com">Ejemplo sin coincidencia</a><br>
    <a href="https://mipagina123.com">Variante de Mi Página</a>
    <p>Este método es útil para resaltar enlaces relacionados con un tema específico dentro de una página web, ayudando a mejorar la experiencia del usuario y la navegación.</p>
    <img src="images/imagen14.jpeg" alt="" width="400">
    <img src="images/imagen15.jpeg" alt="" width="200">
    <hr>

    <div class="mayusculas minusculas">
      <h3>Mayúsculas y minúsculas</h3>
      <p>Algo importante que cabe destacar, es que estos fragmentos de código para seleccionar atributos CSS son sensibles a mayúsculas y minúsculas</p>
      <p>Sin la i, solo se aplicarían estilos a enlaces que terminan exactamente en .pdf (minúsculas). Con la i, se ignoran diferencias entre mayúsculas y minúsculas, por lo que también se seleccionan .PDF, .PdF, .pDf, etc.</p>
      <a href="documento.pdf">Descargar PDF (minúsculas)</a><br>
      <a href="archivo.PDF">Descargar PDF (mayúsculas)</a><br>
      <a href="reporte.PdF">Descargar PDF (mixto)</a><br>
      <a href="imagen.png">Imagen PNG</a> <!-- No se aplicará el estilo -->
      <p>Esto es útil para mejorar la accesibilidad y evitar errores cuando los nombres de archivo pueden variar en escritura.</p>
    </div>
    <img src="images/imagen16.jpeg" alt="" width="300">
    <img src="images/imagen17.jpeg" alt="" width="300">
  </section>
  <hr>

  <section>
    <h1>Metodología BEM</h1>
    <p>La Metodología BEM (Block, Element, Modifier) es un enfoque de nomenclatura de clases en CSS que ayuda a estructurar y organizar el código de manera más clara y mantenible.</p>
    
    <h3>Bloque (Block):</h3>
    <strong>Definición: </strong>Un bloque es un componente independiente y autónomo que tiene un significado propio. Es una entidad visual o de interfaz de usuario que se puede reutilizar.<br>
    <strong>Convención de nomenclatura: </strong>Utiliza un nombre descriptivo en minúsculas, sin espacios ni caracteres especiales. Para separar palabras, usa guiones (-).
    
    <h3>Elemento (Element):</h3>
    <strong>Definición: </strong>Un elemento es una parte de un bloque que no tiene significado propio y que no se puede reutilizar independientemente del bloque al que pertenece.<br>
    <strong>Convención de nomenclatura: </strong> El nombre del elemento se construye añadiendo un doble guion bajo (__) al bloque, seguido por el nombre del elemento.

    <h3>Modificador (Modifier): </h3>
    <strong>Definición: </strong>Un modificador es una variación o estado de un bloque o elemento. Se utiliza para cambiar la apariencia o comportamiento del bloque o elemento sin modificar su estructura principal.<br>
    <strong>Convención de nomenclatura: </strong>El nombre del modificador se construye añadiendo un doble guion (-) al bloque o elemento, seguido por el nombre del modificador.
    <p>Esta metodología facilita la identificación y el mantenimiento de estilos, especialmente en proyectos grandes, al proporcionar una estructura clara y jerárquica para las clases de CSS, un ejemplo a continuación:</p>
    
    <header class="encabezado">
      <nav class="encabezado__navegacion">
        <ul>
          <li class="menu__item"><a href="#" class="menu__enlace menu__enlace--activo">Inicio</a></li>
          <li class="menu__item"><a href="#" class="menu__enlace">Acerca de</a></li>
          <li class="menu__item"><a href="#" class="menu__enlace">Servicios</a></li>
          <li class="menu__item"><a href="#" class="menu__enlace">Contacto</a></li>
        </ul>
      </nav>
    </header>
  
    <main class="contenido">
      <section class="seccion">
        <h2 class="seccion__titulo">Bienvenido</h2>
        <p class="seccion__texto">Explora nuestros servicios y descubre lo que podemos ofrecerte.</p>
      </section>
    
      <section class="seccion seccion--destacada">
        <h2 class="seccion__titulo">Sobre Nosotros</h2>
        <p class="seccion__texto">Somos una empresa enfocada en brindar soluciones digitales innovadoras.</p>
      </section>
    </main>
    
    <footer class="pie">
      <p class="pie__texto">© 2025 Empresa XYZ.</p>
    </footer>

    <p>Se usaron <strong>bloques</strong> (.encabezado, .menu, .seccion, .pie). Se definieron <strong>elementos </strong>(.menu__enlace, .seccion__titulo). Se aplicaron <strong>modificadores </strong>(.menu__enlace--activo, .seccion--destacada).</p>
    <img src="images/imagen18.jpeg" alt="" width="600">
  </section>
  <hr>

  <section>
    <h1>Combinadores</h1>
    <p>Aparte de los selectores CSS básicos, como los de elementos, clases, IDs e incluso atributos, existen múltiples enfoques para crear selectores más avanzados que permiten una selección más precisa y versátil de elementos HTML.</p>
    <h3>¿Qué es un Combinador CSS?</h3>
    <p>Un combinador CSS es un símbolo que permite unir dos o más selectores CSS para crear uno más complejo y potente. CSS ofrece varios tipos de combinadores. </p>
    <table border="1" width="800">
      <tr>
        <th>Nombre</th>
        <th>Simbolo</th>
        <th>Ejemplo</th>
        <th>Significado</th>
      </tr>
      <tr>
        <td>Combinador descendiente</td>
        <td>(espacio)</td>
        <td>#page div { }</td>
        <td>Selecciona elementos dentro de otros (cualquier nivel).</td>
      </tr>
      <tr>
        <td>Combinador hijo</td>
        <td>></td>
        <td>#page > div { }</td>
        <td>Selecciona elementos hijos directos (primer nivel).</td>
      </tr>
      <tr>
        <td>Combinador hermano adyacente</td>
        <td>+</td>
        <td>div + div { }</td>
        <td>Selecciona elementos contiguos a otros (mismo nivel).</td>
      </tr>
      <tr>
        <td>Combinador hermano general</td>
        <td>~</td>
        <td>div ~ div { }</td>
        <td>Selecciona elementos que siguen a otros (mismo nivel).</td>
      </tr>
      <tr>
        <td>Combinador universal</td>
        <td>*</td>
        <td>#page * { }</td>
        <td>elecciona todos los elementos de (cualquier nivel).</td>
      </tr>
    </table>

    <h3>Combinador descendiente</h3>
    <p>En CSS, se utiliza el término selector descendiente para referirse a una forma de seleccionar elementos específicos que están contenidos dentro de otros elementos.</p>
    <div class="combinador descendiente">
      <div class="caja">
        <p>Texto dentro de .caja</p>
        <span>Otro texto dentro de .caja</span>
      </div>
      <p>Texto dentro de .contenedor pero fuera de .caja</p>
      <p>.contenedor .caja span → Selecciona cualquier <span> que esté dentro de un elemento con clase .caja que, a su vez, esté dentro de .contenedor.</p>
      <img src="images/imagen19.jpeg" alt="" width="400">
      <img src="images/imagen20.jpeg" alt="" width="300">
      </div>

    <h3>Combinador hijo</h3>
    <p>Aunque el selector descendiente es bastante interesante, nos puede interesar hacer la misma operación, pero en lugar de seleccionar todos los elementos descendientes, seleccione solo los descendientes directos del elemento con el símbolo  > , descartando así nietos y sucesivos.</p>
    <div class="contenedor-principal">
      <div class="seccion">Este div es hijo directo de .contenedor-principal</div>
      
      <div class="bloque-intermedio">
        <div class="seccion">Este div está dentro de otro div, NO es hijo directo de .contenedor-principal</div>
      </div>
  
      <div class="seccion">Otro div hijo directo de .contenedor-principal</div>
    </div>
    <p>El primer <strong>div class="seccion"</strong> dentro de .contenedor-principal → se verá azul claro porque es hijo directo. <br>
      El segundo <strong>div class="seccion"></strong>, dentro de <strong>div class="bloque-intermedio"</strong> → ❌ NO recibe los estilos, porque no es hijo directo de .contenedor-principal, sino nieto. <br>
      El tercer <strong>div class="seccion"</strong> dentro de .contenedor-principal → también recibe los estilos, porque es hijo directo.
    </p>
    <img src="images/imagen21.jpeg" alt="" width="300">
    <img src="images/imagen22.jpeg" alt="" width="300">

    <h3>Combinador hermano contiguo</h3>
    <p>También es factible hacer referencia a elementos hermanos, que son aquellos elementos que están directamente adyacentes al elemento especificado. Utilizando el símbolo  +  en el selector de hermano adyacente, es posible seleccionar elementos hermanos que están uno junto al otro en el mismo nivel.</p>
    <div class="articulo">
      <span class="etiqueta">Primera etiqueta (NO se aplica el estilo)</span>
      <span class="etiqueta">Segunda etiqueta (✅ Se aplica el estilo)</span>
      <span class="etiqueta">Tercera etiqueta (✅ Se aplica el estilo)</span>
  
      <p>Este párrafo interrumpe la secuencia.</p>
  
      <span class="etiqueta">Cuarta etiqueta (NO se aplica, porque no está inmediatamente después de otra span)</span>
    </div>
    <p>El primer span ❌ NO recibe estilos, porque no tiene otro span antes de él. <br>
      El segundo span ✅ RECIBE los estilos, porque tiene un span antes. <br>
      El tercer span ✅ RECIBE los estilos, porque tiene un span antes.
      El cuarto span ❌ NO recibe estilos, porque antes hay un p, lo que rompe la secuencia.
    </p>
    <img src="images/imagen23.jpeg" alt="" width="400">
    
    <h3>Combinador hermano general</h3>
    <p>Si consideramos otras posibilidades en el ejemplo anterior, es posible que necesitemos ser menos específicos. En lugar de seleccionar solo los elementos que son adyacentes, podríamos querer seleccionar todos los hermanos en general, sin requerir que sean adyacentes. Esto se logra utilizando el "selector hermano general, que se representa con el símbolo  ~.</p>
    <div class="contenedor">
      <p>Este párrafo no se verá afectado.</p>
      <strong>Primer elemento fuerte (✅ Se aplica el estilo)</strong><br>
      <em>Elemento en cursiva (NO se aplica, porque no es un strong)</em><br>
      <strong>Segundo elemento fuerte (✅ Se aplica el estilo)</strong><br>
      <span>Un span cualquiera (NO se aplica, porque no es un strong)</span><br>
      <strong>Tercer elemento fuerte (✅ Se aplica el estilo)</strong>
    </div>
    <p>p ~ strong dentro de .contenedor → Significa: "Selecciona todos los strong que sean hermanos de p, sin importar si están adyacentes o no".</p>
    <p>
      El p ❌ NO recibe estilos (es solo la referencia). <br>
      El primer strong ✅ RECIBE los estilos, porque es un hermano posterior de p. <br>
      El em ❌ NO recibe estilos, porque no es un strong. <br>
      El segundo strong ✅ RECIBE los estilos, porque es un hermano posterior de p. <br>
      El span ❌ NO recibe estilos, porque no es un strong.<br>
      El tercer strong ✅ RECIBE los estilos, porque es un hermano posterior de p.
    </p>
    <img src="images/imagen24.jpeg" alt="" width="300">

    <h3>Combinador universal</h3>
    <p>se simboliza con un asterisco  *  y es la forma de aplicar ciertos estilos en TODOS Y CADA UNO de los elementos HTML correspondientes.</p>
    <div id="menu">
      <h2>Menú Principal</h2>
      <ul>
        <li><a href="#">Inicio</a></li>
        <li><a href="#">Servicios</a></li>
        <li><a href="#">Contacto</a></li>
      </ul>
      <p>Bienvenido a nuestra página.</p>
    </div>
    <p>#menu * → Selecciona todos los elementos dentro de div#menu, sin importar qué tipo de etiqueta sean h2, ul, li, a, p, etc.</p>
    <img src="images/imagen25.jpeg" alt="" width="400">
  </section>
  <hr>

  <section>
    <h1>Combinadores Lógicos</h1>
    <p>En algunas ocasiones, puede ser deseable agrupar varios selectores con el fin de reducir la cantidad de código o reutilizar bloques de CSS en diversas situaciones, lo que hace que los estilos sean más versátiles y eficientes. La forma más sencilla de conseguir esto, es crear agrupaciones con diferentes selectores separando por comas.</p>
    
    <h3>Agrupación de selectores</h3>
    <div class="letrero logo">Logo</div>
    <div class="letrero alerta">¡Alerta!</div>
    <div class="letrero advertencia">Advertencia</div>
    <img src="images/imagen26.jpeg" alt="" width="400">
    <p> ⚠️ Problema: El mismo código se repite tres veces, lo que hace el CSS más largo y difícil de mantener.</p>
    <p> En el siguiente ejemplo repetimos el mismo codigo pero en el css esta mejor optimizado aun asi funciona de la misma forma que el primero.</p>
    <div class="letrero logo2">Logo</div>
    <div class="letrero alerta2">¡Alerta!</div>
    <div class="letrero advertencia2">Advertencia</div>
    <img src="images/imagen27.jpeg" alt="" width="400">
    <h3>¿Qué es un combinador lógico?</h3>
    <p>Sin embargo, las comas sólo son la forma más sencilla y simple de reutilizar selectores. En CSS, tenemos a nuestra disposición una serie de mecanismos para agrupar o combinar selectores de una forma más potente y flexible.</p>

    <h3>El combinador :is()</h3>
    <p>La pseudoclase funcional  :is()  es un reemplazo práctico de la agrupación de selectores mediante comas, que permite reescribir selectores complejos de una forma mucho más práctica y compacta, ya que permite combinar y acumular con otros selectores anteriores o posteriores a  :is().</p>
    <div class="container">
      <div class="list">Soy un elemento de la lista</div>
      <div class="menu">Soy parte del menú</div>
      <ul>
        <li>Ítem 1</li>
        <li>Ítem 2</li>
      </ul>
    </div>
    <img src="images/imagen28.jpeg" alt="" width="500">
    <p>Significa que todos los elementos .list, .menu y ul que estén dentro de .container tendrán el texto de color azul. Sin :is(), el código sería más largo.</p>
    
    <h3>El combinador :where()</h3>
    <p>Los combinadores `:is() y :where() funcionan igual, pero la diferencia está en la especificidad: :is() → Toma la especificidad del selector más alto dentro de la lista :where() → Siempre tiene especificidad 0, lo que facilita su sobreescritura con otros selectores.</p>
    <div class="container">
      <div class="list">Soy un elemento de la lista</div>
      <div class="element">Soy otro elemento</div>
      <div class="menu">Soy parte del menú</div>
    </div><br>
    <img src="images/imagen29.jpeg" alt="" width="600">
    <p>Como :is() tiene mayor especificidad (0,2,0) y :where() (0,1,0), el color final de .list y .menu será verde azulado (por :is()). </p>
    
    <h3>El combinador :has()</h3>
    <p>Nos permite seleccionar un elemento padre si contiene ciertos elementos hijos. Es la única pseudoclase en CSS que permite este comportamiento, ya que normalmente los selectores solo funcionan de padre a hijo.</p>
    <a href="#">Enlace normal</a><br>
    <a href="#"><img src="imagen.jpg" alt="Imagen dentro del enlace"> Enlace con imagen</a><br><br>
    <img src="images/imagen30.jpeg" alt="" width="600">
    <img src="images/imagen31.jpeg" alt="" width="600">
    
    <h3>El combinador :not()</h3>
    <p> permite seleccionar todos los elementos que NO cumplan una condición dada.</p>
    <strong>Ejemplo útil:</strong> Aplicar estilos a todos los párrafos < p > excepto los que tienen la clase .general.
    <div class="combinador not">
      <p>Este párrafo tendrá el estilo del :not()</p>
      <p class="general">Este párrafo NO tendrá el estilo porque tiene la clase .general</p>
      <p>Otro párrafo con el estilo aplicado</p>
      <p>Los párrafos que NO tienen la clase .general tendrán:</p>
    </div>
    <img src="images/imagen32.jpeg" alt="" width="600">
    <img src="images/imagen33.jpeg" alt="" width="600">
    <h4 class="recordatorio_div"> Recuerda que todos los div del documento tienen fondo AZUL y letra BLANCA, por lo que el segundo parrafo no se le esta dando ningun estilo en este ejemplo.</h4>
    
  </section>
  <hr>

  <section>
    <h1>Pseudoclases</h1>
    <h3>¿Qué es una pseudoclase CSS?</h3>
    <p>Las pseudoclases se utilizan para hacer referencia a elementos HTML que tengan un cierto comportamiento concreto.</p>
    <h3>Tipos de pseudoclases CSS</h3>
    <p>Existen múltiples pseudoclases, así que para entenderlas mejor, las categorizamos en las siguientes secciones.</p>
    <h3>1. Pseudoclase Interacción</h3>
    <p> relacionadas con acciones de usuario.</p>
    <table border="1" width="800">
      <tr>
        <th>Pseudoclase</th>
        <th>Descripción</th>
      </tr>
      <tr>
        <td>:hover</td>
        <td>Selecciona el elemento si el usuario pasa el ratón sobre dicho elemento.</td>
      </tr>
      <tr>
        <td>:active</td>
        <td>Selecciona el elemento si el usuario se encuentra pulsando dicho elemento.</td>
      </tr>
      <tr>
        <td>:focus</td>
        <td>Selecciona el elemento cuando tiene el foco (está en primer plano).</td>
      </tr>
      <tr>
        <td>:focus-within</td>
        <td>Selecciona el elemento si uno de sus miembros hijos ha ganado el foco.</td>
      </tr>
      <tr>
        <td>:focus-visible</td>
        <td>Selecciona el elemento cuando tiene el foco sólo de forma visible (TAB, por ejemplo).</td>
      </tr>
    </table>

    <h3>Pseudoclase :hover</h3>
    <p>La primera de ellas, :hover, es muy útil e interesante, ya que permite aplicar estilos a un elemento justo cuando el usuario pasa el ratón (o más concretamente, un dispositivo apuntador) sobre él. Es una de las pseudoclases más utilizadas.</p>
    <section class="ejemplo-hover">
      <p><a href="#">Enlace 1</a></p>
      <p><a href="#">Enlace 2</a></p>
      <div>
        <p><a href="#">Enlace dentro de un div</a></p>
      </div>
    </section>
    <p>En nuestro css lo utilizamos de esta forma <strong>.ejemplo-hover a:hover {}</strong></p>

    <h3>Pseudoclase :active</h3>
    <p>Por otro lado, la segunda pseudoclase, :active, permite resaltar los elementos que se encuentran activos, o lo que es lo mismo, elementos que están siendo pulsados en ese instante con el ratón por el usuario. En este ejemplo saldra un borde rojo al oprimir con el mouse.</p>
    <a href="#">Haz clic aquí</a>
    <p>en nuestro css <strong>a:active{}</strong></p>
    
    <h3>Pseudoclase :focus</h3>
    <p>Cuando estamos escribiendo en un campo de texto de un formulario de una página web, generalmente pulsamos TAB para cambiar al siguiente campo y SHIFT+TAB para volver al anterior. Cuando estamos posicionados en un elemento, se dice que ese elemento tiene el foco, mientras que al pulsar TAB y saltar a otro, solemos decir que pierde el foco. También es posible ganar o perder el foco pulsando con el ratón en un elemento.</p>
    <section class="ejemplo-focus">
      <label for="nombre">Nombre:</label>
      <input type="text" id="nombre" name="nombre"><br><br>
  
      <label for="email">Email:</label>
      <input type="email" id="email" name="email"><br><br>
  
      <label for="telefono">Teléfono:</label>
      <input type="tel" id="telefono" name="telefono">
    </section>
    <p>Cuando un usuario hace clic en un campo de entrada o navega con TAB, el borde se vuelve azul y el fondo cambia a un color rosado.</p>
    <p>En nuestro css: <br>
      <strong>
        .ejemplo-focus input:focus {<br>
        border: 2px solid blue;<br>
        background-color: #ffb0e1;<br>
        outline: none; /* Elimina el contorno predeterminado */
        }
      </strong>
    </p>
    
    <h3>Pseudoclase :focus-within</h3>
    <p>La pseudoclase :focus-within permite darle estilo no solo al elemento que tiene el foco, sino también a los elementos contenedores relacionados con el elemento que gana el foco.</p>
    <section class="ejemplo-focus-within">
      <form>
        <label>Nombre: <input type="text"></label>
        <label>Email: <input type="email"></label>
      </form>
    </section>
    <p>En nuestro css lo escribimos de la siguiente forma: <br>
      <strong>
        .ejemplo-focus-within form:focus-within {<br>
          background: yellow;<br>
          padding: 10px;
        }
      </strong>
    </p>
    
    <h3>Pseudoclase :focus-visible</h3>
    <p> Es prácticamente idéntico a :focus, solo que podemos aplicar estilos al elemento que gana el foco, pero sólo cuando se ha ganado el foco exclusivamente de forma visible, como por ejemplo, pulsando la tecla TAB y accediendo al elemento. Esto puede resultar muy útil cuando quieres que el foco coincida con un tema visual para la página.</p>
    <section class="ejemplo-focus-visible">
      <label for="nombre">Nombre:</label>
      <input type="text" id="nombre" name="nombre"><br><br>
  
      <label for="email">Email:</label>
      <input type="email" id="email" name="email"><br><br>
  
      <label for="telefono">Teléfono:</label>
      <input type="tel" id="telefono" name="telefono">
    </section>
    <p>Para ver el efecto, usa la tecla TAB para moverte entre los campos de entrada. Solo el campo con foco visible tendrá un borde azul.</p>
    <p>En el archivo css lo escribimos de la siguiente forma: <br>
      <strong>
        .ejemplo-focus-visible input:focus-visible {<br>
          border: 2px solid blue;<br>
          background-color: gold;<br>
          outline: none; /* Evita el borde predeterminado del navegador */
        }
      </strong>
    </p>

    <h3>2. Pseudoclases de ubicación</h3>
    <table border="1" width="800">
      <tr>
        <th>Pseudoclase</th>
        <th>Descripción</th>
      </tr>
      <tr>
        <td>:any-link</td>
        <td>Selecciona un elemento que es un enlace.
      </tr>
      <tr>
        <td>:link</td>
        <td>Selecciona un elemento que es un enlace no visitado aún.
      </tr>
      <tr>
        <td>:target</td>
        <td>Selecciona un elemento que coincide con el ancla de la URL actual.</tr>
    </table>

    <h3>Pseudoclase :any-link</h3>
    <p>se puede hacer referencia, como dice su nombre, a elementos que sean cualquier tipo de enlaces. En este caso, y si no se delimitan de alguna forma, incluye etiquetas <a> y <area>, ya que ambas se consideran enlaces.</p>
    <p>Solo los enlaces dentro de la siguiente sección serán estilizados.</p>
    <section class="contenedor-enlaces">
      <p><a href="#">Enlace dentro de la sección</a></p>
      <p><a href="#">Otro enlace dentro de la sección</a></p>
    </section>
    <p>Este <a href="#">enlace fuera de la sección</a> no será afectado.</p>
    <img src="images/imagen34.jpeg" alt="" width="500">

    <h3>Pseudoclase :link</h3>
    <p>Por otro lado, la pseudoclase :link permite seleccionar enlaces a páginas que aún no han sido visitadas por el navegador del usuario, lo que puede ser interesante para personalizar el color de este tipo de enlaces.</p>
    <strong>Ejemplo: </strong>Cambiar el color y estilo de los enlaces no visitados. Los enlaces que aún no han sido visitados aparecerán en rojo subrayado.
    <section class="especial">
      <p><a href="https://www.ejemplo.com" target="_blank">Enlace especial no visitado</a></p>
      <p><a href="https://www.google.com" target="_blank">Otro enlace especial</a></p>
    </section>
    <p> En nuestro archivo css lo escribimos de esta forma: <br>
      <strong>
        .especial a:link {<br>
        color: red;<br>
        text-decoration: underline;<br>
        }
      </strong>
    </p>

    <h3>Pseudoclase :visited</h3>
    <p>También tenemos la pseudoclase :visited, que se utiliza para seleccionar y dar estilo a los enlaces que hayan sido visitados previamente en el navegador del usuario. </p>
    <section class="historial">
      <p><a href="https://web.facebook.com/?locale=es_LA&_rdc=1&_rdr#" target="_blank">Enlace visitado especial</a></p>
      <p><a href="https://www.youtube.com/watch?v=1J5CIzQAlgY" target="_blank">Otro enlace visitado especial</a></p>
    </section>
    <p> En nuestro archivo css lo escribimos de esta forma: <br>
      <strong>
        .historial a:visited {<br>
          color: darkgreen;<br>
          font-style: italic;<br>
        }
      </strong>
    </p>

    <h3>Pseudoclase :target</h3>
    <p>Podemos seleccionar un elemento HTML donde su id (ancla) coincida con el ancla que tenemos actualmente en la URL de navegación. Ideal para seleccionar cabeceras de secciones a modo de ancla en un documento HTML.</p>
    <nav>
      <a href="#seccion1">Ir a Sección 1</a> |
      <a href="#seccion2">Ir a Sección 2</a> |
      <a href="#seccion3">Ir a Sección 3</a>
    </nav>
    <section id="seccion1">Esta es la Sección 1.</section>
    <section id="seccion2">Esta es la Sección 2.</section>
    <section id="seccion3">Esta es la Sección 3.</section>
    <p>Cuando se haga clic en "Ir a Sección 1", el fondo de esa sección cambiará a azul claro.</p>
    <p> En nuestro archivo css lo escribimos de esta forma: <br>
      <strong>
        :target {<br>
          background: lightblue;<br>
          color: black;<br>
          font-weight: bold;<br>
        }
      </strong>
    </p>

    <h3>3. Pseudoclases de idioma</h3>
    <p>:lang(es) : Selecciona elementos con el idioma español, es decir, atributo lang="es". :dir(value) : Selecciona elementos con la dirección indicada (ltr o rtl).</p>
    
    <h3>Pseudoclase :lang()</h3>
    <p>Anteriormente ya habiamos visto un poco sobre este atributo. El atributo HTML lang permite indicar en una etiqueta HTML el idioma en el que está el contenido de sus elementos hijos. De esta forma, un atributo lang="es" indica que el contenido de esa etiqueta se encuentra generalmente en español. La pseudoclase :lang() acepta por parámetro un idioma (o una lista de ellos separados por comas) para seleccionar el elemento HTML que coincida con uno de ellos.</p>
    <div class="idioma-destacado">
      <p lang="es">Este es un párrafo en español.</p>
      <p lang="en">This is a paragraph in English.</p>
      <p lang="fr">Ceci est un paragraphe en français.</p>
    </div>
    <p lang="es">Este párrafo en español no será afectado.</p>
    <img src="images/imagen35.jpeg" alt="" width="200">

    <h3>Pseudoclase :dir()</h3>
    <p>permite seleccionar elementos dependiendo de la dirección que tienen establecida. Generalmente, la direccionalidad del texto se establece con el atributo dir, indicándole el valor ltr (left to right) o el valor rtl (right to left), sin embargo, con valores como auto o sin valores indicados, también tendrán una direccionalidad dependiendo del lenguaje establecido en el documento o fragmento.</p>
    <p>Este es un texto normal que no se ve afectado por la pseudoclase.</p>

    <div class="caja-texto" dir="ltr">
        <p>Texto en dirección izquierda a derecha (LTR).</p>
    </div>

    <div class="caja-texto" dir="rtl">
        <p>نص باللغة العربية (RTL).</p>
    </div>
    <img src="images/imagen36.jpeg" alt="" width="300">

    <h3>4. Pseudoclases de estado</h3>
    <p>Existen una serie de pseudoclases para comprobar el estado visual de un elemento que se considera modal, es decir, que «centran» la interacción del usuario en un elemento principal (y sus hijos) y no permiten la interacción con otros elementos hasta que se cierre ese elemento principal.</p>
    <h3>Pseudoclase :fullscreen</h3>
    <p>Mediante la pseudoclase :fullscreen podemos seleccionar elementos que se encuentren en modo pantalla completa, lo que habitualmente se realiza mediante la API FullScreen de Javascript.</p>
    <div class="screen" id="screen">
      <p>Colocar esta ventana en pantalla completa</p>
      <button class="close">Cerrar</button>
    </div>
    <button onclick="document.getElementById('screen').requestFullscreen()">Pantalla Completa</button><br><br>
    <img src="images/imagen37.jpeg" alt="" width="400">
  </section>
  <hr>

  <section>
    <h1>Pseudoclases de estructura</h1>
    <p>Existe una amplia gama de pseudoclases que permiten seleccionar elementos de un documento HTML según su posición y/o estructura en el documento.</p>
    <h3>Elementos raíz</h3>
    <p>Existen algunas pseudoclases con las que podemos hacer referencia al elemento padre raíz del documento donde estamos trabajando. En el caso de estar trabajando en un documento HTML, el elemento raíz es <html>, mientras que en el caso de estar trabajando en un componente, el elemento raíz es el propio componente. Las pseudoclases que podemos usar en cada caso son las siguientes:</p>
    
    <h3>Pseudoclase :root</h3>
    <p> hace referencia al elemento raíz del documento HTML, o lo que es lo mismo, la etiqueta <html>. Sin embargo, en muchas ocasiones se puede ver que, en lugar de utilizar directamente la etiqueta, se utiliza la pseudoclase :root. Al ser una pseudoclase, tiene una especificidad CSS más alta (0,1,0) que el elemento html, el cuál, al ser una etiqueta HTML, tiene una especificidad más baja (0,0,1):</p>
    <p>El siguiente ejemplo tendrá estilos aplicados de forma específica.</p>

    <!-- Solo este section tendrá los estilos aplicados -->
    <section class="root">
      <header>
        <h1>Ejemplo de Pseudoclase :root</h1>
      </header>
  
      <main>
        <section>
          <div class="caja caja-1">Caja 1</div>          
          <div class="caja caja-2">Caja 2</div>
          <div class="caja caja-3">Caja 3</div>
        </section>
      </main>
  
      <footer>
        <p>Todos los derechos reservados &copy; 2025</p>
      </footer>  
    </section> 
     <h4>Explicación del uso de :root y .root en este documento:</h4>
      <p>Crea variables CSS globales (--color-primario, --color-secundario, etc.). Permite reutilizar los mismos valores en todo el documento sin repetir código. Facilita la modificación del diseño, porque si cambias un valor en :root, se reflejará automáticamente en todas las partes del código que usen esa variable.</p>
      <p>Aquí, en vez de escribir colores específicos en cada clase, usamos las variables que definimos en :root. Esto hace que, si queremos cambiar el color primario, solo lo hacemos en :root y automáticamente se actualizará en toda la página.</p>
      <p>Adicional manejamos la variable global body en la que se modificamos pequños detalles.</p>
      <img src="images/imagen38.jpeg" alt="" width="300">

    <h3>Pseudoclase :first-child</h3>
    <p>Con la pseudoclase :first-child podemos seleccionar el primer elemento (o primeros elementos) de un grupo de elementos al mismo nivel. De esta forma, si indicamos .container :first-child buscará todos los primeros elementos que encuentre:</p>
    <div class="ejemplo-first-child">
      <div class="elementos">
        <div class="elemento">Elemento A</div>
        <div class="elemento">Elemento B</div>
        <div class="elemento">Elemento C</div>
      </div>
      <div class="elementos">
        <div class="elemento">Elemento D</div>
        <div class="elemento">Elemento E</div>
        <div class="elemento">Elemento F</div>
      </div>
    </div>
    <p><strong>.elements:first-child .element:first-child { background-color: lightblue; }</strong>
      Selecciona el primer .elemento dentro del primer div .elementos. Aplica un fondo azul (lightblue).
      <strong>.elements:nth-child(2) .element:first-child { background-color: lightcoral; }</strong>
      Selecciona el primer .elemento dentro del segundo div .elementos. Aplica un fondo rojo coral (lightcoral).
    </p>


    <h3>Pseudoclase :last-child</h3>
    <p>Podemos seleccionar el último elemento (o últimos elementos). Funciona exactamente igual que :first-child pero haciendo referencia al último elemento en lugar del primero.</p>
    <div class="ejemplo last-child">
      <p>Primer párrafo con <strong>texto fuerte</strong> y <strong>otro texto fuerte</strong>.</p>
      <p>Segundo párrafo con <strong>texto fuerte</strong> y <strong>otro texto fuerte</strong>.</p>
      <p>Tercer párrafo con <strong>texto fuerte</strong> y <strong>otro texto fuerte</strong>.</p>
    </div>
    :last-child selecciona el último < strong > dentro de cada < p >.
    <img src="images/imagen39.jpeg" alt="" width="700">

    <h3>Hijos específicos</h3>
    <p>Sin embargo, con las pseudoclases anteriores solo podemos seleccionar los primeros y últimos elementos, y podríamos necesitar un elemento específico, como el tercero o el quinto, por ejemplo. Para ello, podemos utilizar pseudoclases funcionales como :nth-child() o :nth-last-child().</p>
  
    <h3>Pseudoclase :nth-child()</h3>
    <p>La pseudoclase :nth-child(n) en CSS nos permite seleccionar y aplicar estilos a elementos específicos según su posición dentro de su contenedor padre. Esto nos ayuda a resaltar o diferenciar elementos de una lista o conjunto de elementos sin necesidad de agregar clases adicionales.</p>
    <div class="ejemplo-nth-child">
      <p>Elemento 1</p>
      <p>Elemento 2</p>
      <p>Elemento 3</p>
      <p>Elemento 4</p>        
      <p>Elemento 5</p>
    </div>
    <ul>
      <li>p:nth-child(2) → Aplica color azul al segundo hijo</li>
      <li>p:nth-child(3n) → Aplica fondo negro a todos los elementos múltiplos de 3</li>
      <li>p:nth-child(2n) → Aplica un fondo azul claro a los elementos pares</li>
    </ul>
    
    <h3>Pseudoclase :nth-last-child()</h3>
    <p>La diferencia respecto a la anterior, es que comenzamos a contar desde el final, de modo que su visualización cambiará por el mismo orden establecido.</p>
    <div class="ejemplo-nth-last-child">
      <p>Elemento 1</p>
      <p>Elemento 2</p>
      <p>Elemento 3</p>
      <p>Elemento 4</p>        
      <p>Elemento 5</p>
      <p>Elemento 6</p>
      <p>Elemento 7</p>        
      <p>Elemento 8</p>
      <p>Elemento 9</p>
    </div>
    <img src="images/imagen40.jpeg" alt="" width="500">
    
    <h3>Pseudoclase :nth-child(A of B)</h3>
    <p>Permite hacer selecciones más precisas dentro de un grupo de elementos que cumplen ciertas condiciones. <br>
      <strong>A:</strong>Representa la posición dentro del subconjunto de elementos filtrados. <br>
      <strong>B:</strong>Define el tipo de elementos que queremos considerar dentro del contenedor.
    </p>
    <div class="A-of-B">
      <button class="boton">Botón 1</button>
      <button class="boton importante">Botón 2 (importante)</button>
      <button class="boton">Botón 3</button>
      <button class="boton importante">Botón 4 (importante, cambia a naranja)</button>
      <button class="boton">Botón 5</button>
      <button class="boton importante">Botón 6 (importante)</button>
    </div>
    <p><strong>.A-of-B :nth-child(2 of .importante)</strong> Busca solo dentro de los hijos de .A-of-B, filtra los elementos que tienen la clase .importante. Aplica estilos al segundo elemento dentro de los filtrados (en este caso, el botón 4).</p>
    <ul>
      <li>El Botón 2 tiene .importante (primer elemento del grupo filtrado).</li>
      <li>El Botón 4 tiene .importante (segundo elemento del grupo filtrado → se le aplica el fondo naranja).</li>
      <li>El Botón 6 tiene .importante (tercer elemento del grupo filtrado, no cambia).</li>
    </ul>
  
    <h3>Hijos (del mismo tipo)</h3>
    <p>En los casos anteriores, seleccionamos elementos independientemente de qué tipo de elemento sea. Simplemente, hacemos caso a la posición donde está ubicado. Y en algún caso, si no coincide la posición con el tipo de elemento especificado en el selector, simplemente no lo selecciona. Una forma de actuar, quizás, más predecible para nosotros, es que queramos hacer referencia solo a elementos del mismo tipo, ignorando el resto. Para ello, utilizaremos los selectores siguientes, análogos a los que ya hemos visto, pero haciendo referencia solo a elementos del mismo tipo:</p>
    <table border="1" width="600">
      <tr>
        <th>Pseudoclase</th>
        <th>Descripción</th>
      </tr>
      <tr>
        <td>:first-of-type</td>
        <td>Primer elemento hijo (de su mismo tipo).</td>
      </tr>
      <tr>
        <td>:last-of-type</td>
        <td>Último elemento hijo (de su mismo tipo).</td>
      </tr>
    </table>

    <h3>Hijos específicos (del mismo tipo)</h3>
    <p>Ahora que estamos en la categoría en la que queremos seleccionar elementos del mismo tipo, también nos puede interesar seleccionar elementos específicos. Para ello, tenemos también dos pseudoclases análogas a las anteriores:</p>
    <table border="1" width="600">
      <tr>
        <th>Pseudoclase</th>
        <th>Descripción</th>
      </tr>
      <tr>
        <td>:nth-of-type(n)</td>
        <td>Elemento hijo número n (de su mismo tipo).</td>
      </tr>
      <tr>
        <td>:nth-last-of-type(n)</td>
        <td>Elemento hijo número n empezando desde el final (de su mismo tipo).</td>
      </tr>
    </table>

    <h3>Pseudoclase :nth-of-type()</h3>
    <p>La pseudoclase :nth-of-type(A) es la análoga a :nth-child(A). Se trata de una pseudoclase funcional que admite pasar parámetros, donde le podemos indicar un número (o cierta expresión) para ser mucho más específicos a la hora de seleccionar elementos del mismo tipo.</p>
    <div class="nth-of-type">
      <div class="cajaA">Div 1</div>
      <p class="text">Párrafo 1</p>
      <div class="cajaA">Div 2 (Será azul claro)</div>
      <p class="text">Párrafo 2</p>
      <div class="cajaA">Div 3</div>
      <div class="cajaA">Div 4 (Será verde claro)</div>
    </div>
    <p><strong>.nth-of-type div:nth-of-type(2): </strong>Selecciona el segundo < div > dentro de .nth-of-type (sin contar los < p> ). Div 2 tendrá un fondo azul claro. <br>
      <strong>.nth-of-type div:nth-of-type(4): </strong> Selecciona el cuarto < div > dentro de .container. Div 4 tendrá un fondo verde claro. <br>
      Los < p > NO afectan la cuenta. <br>
      Aunque Párrafo 1 está antes de Div 2, no se cuenta porque nth-of-type() solo considera elementos del mismo tipo (div en este caso).
    </p>

    <h3>Pseudoclase :nth-last-of-type()</h3>
    <p>La pseudoclase :nth-last-of-type(A) es la análoga a :nth-last-child(A).</p>
    <div class="nth-last-of-type">
      <div class="cajaA">Div 1</div>
      <p class="text">Párrafo 1</p>
      <div class="cajaA">Div 2 (Será azul claro)</div>
      <p class="text">Párrafo 2</p>
      <div class="cajaA">Div 3</div>
      <div class="cajaA">Div 4 (Será verde claro)</div>
    </div>

    <h4> Diferencia entre nth-of-type() y nth-last-of-type()</h4>
    <table border="1" width="800">
      <tr>
        <th>Selector</th>
        <th>Cuenta desde...</th>
        <th>Resultado en la lista</th>
      </tr>
      <tr>
        <td>nth-of-type(2)</td>
        <td>El inicio</td>
        <td>Selecciona el segundo párrafo desde el principio</td>
      </tr>
      <tr>
        <td>nth-last-of-type(2)</td>
        <td>El final</td>
        <td>Selecciona el segundo párrafo desde el final</td>
      </tr>
    </table>
    <h4 class="recordatorio_div"> Recuerda que todos los div fueron asignados de fondo AZUL con letra BLANCA.</h4>

    <h3>Elementos únicos o sin hijos</h3>
    <p>Existen también varias pseudoclases para la gestión de hijos únicos.</p>
    
    <h3>Pseudoclase :only-child</h3>
    <p>Nos proporciona una forma de seleccionar los elementos que sean el único hijo de su elemento padre. Por lo tanto, si un contenedor tiene en su interior un sólo elemento hijo, podremos seleccionar y aplicar estilos. <strong>Si el padre tiene más de un hijo, la regla NO se aplica.</strong></p>

    <div class="only-child">
      <p class="hijo-unico">Soy el único hijo, y tengo estilos.</p>
    </div>

    <div class="only-child">
      <p>Hijo 1</p>
      <p>Hijo 2</p>
    </div>

    <h4 class="recordatorio_div">Recuerda que los div son de fondo AZUL y letra BLANCA fue asigando cuando tocamos el tema de <strong>Seleccionar por etiquetas</strong>, en este ejemplo "Hijo 1" y "Hijo 2" no se les esta asigando ningun estilo. </h4>

    <h3>Pseudoclase :only-of-type</h3>
    <p>Además, como ha ocurrido anteriormente, también existe la pseudoclase :only-of-type que es la análoga a la anterior, pero solo para elementos del mismo tipo. En este caso, podríamos tener un contenedor que contiene varios elementos, pero todos son únicos en su tipo; por lo tanto, podrían ser seleccionados.</p>

    <div class="only-of-type">
      <p>Soy el único párrafo en este div, tengo estilos.</p>
      <span>Otro tipo de elemento</span>
    </div>

    <div class="only-of-type">
      <p>Párrafo 1</p>
      <p>Párrafo 2</p>
    </div>

    <div class="only-of-type">
      <span>Soy el único < span >, tengo estilos.</span>
    </div>

    <p><strong>Primer .only-of-type. </strong>Tiene un < p > y un < span >, pero el < p > es único en su tipo → Se le aplica el estilo. Se verá con fondo azul claro, texto blanco y negrita. <br>
      <strong>Segundo .only-of-type. </strong> Tiene dos < p >, por lo que ninguno es único en su tipo → NO se aplica el estilo. <br>
      <strong>Tercer .container. </strong> Tiene un solo < span >, por lo que es único en su tipo → Se le aplica el estilo.
    </p>

    <h3>Pseudoclase :empty</h3>
    <p>Permite seleccionar los elementos que estén vacíos. Ojo con esto, ya que el navegador no considerará vacío el elemento que contiene espacios en blanco. </p>
    <!-- Elemento realmente vacío -->
    <div class="ejemplo empty-1"></div>

    <!-- Contiene espacios en blanco -->
    <div class="ejemplo empty-2"> </div>

    <!-- Contiene un comentario HTML -->
    <div class="ejemplo empty-3">
      <!-- Esto es un comentario -->
    </div>
    <img src="images/imagen41.jpeg" alt="" width="300">
    <p> Con este ejemplo puedes ver cómo :empty realmente solo se aplica a elementos sin nada dentro.</p>
  </section>
  <hr>

  <section>
    <h1>Reglas</h1>
    <p>En CSS tenemos las denominadas «at-rules» (reglas precedidas del carácter @). Son un tipo de declaración especial que permite indicar comportamientos especiales en muchos contextos. Su sintaxis suele determinarse incluyendo una palabra clave que comienza por @ (como por ejemplo @media o @import) y dependiendo de la regla en cuestión, puede tener una sintaxis u otra. <br>En términos generales, las "at-rules" se pueden ubicar en cualquier parte de la hoja de estilos, ya sea al principio, en medio o al final. No obstante, algunas reglas tienen restricciones específicas.</p>
    
    <h3>La regla @import</h3>
    <p> Permite cargar un fichero .css externo, leer sus líneas de código e incorporarlo al archivo actual. Estas reglas CSS se suelen indicar en las primeras líneas del fichero, ya que deben figurar antes de otras reglas CSS o contenido CSS similar.</p>
    <table border="1" witdh="700">
      <tr>
        <th>Tipo de importación</th>
        <th>Descripción</th>
      </tr>
      <tr>
        <td>@import</td>
        <td>Importamos una hoja de estilos CSS externa.</td>
      </tr>
      <tr>
        <td>@import  media query</td>
        <td>Importamos una hoja de estilos CSS sólo si condide con el media query indicado.</td>
      </tr>
      <tr>
        <td>@import  supports(condición)</td>
        <td>Importamos una hoja de estilos CSS sólo si el navegador soporta la condición.</td>
      </tr>
      <tr>
        <td>@import  layer(nombre)</td>
        <td>Importamos una hoja de estilos CSS y la colocamos en la capa nombre.</td>
      </tr>
      <tr>
        <td>@import  layer()</td>
        <td>Importamos una hoja de estilos CSS y la colocamos en una nueva capa anónima.</td>
      </tr>
    </table>
    <p>Un detalle muy importante es que hay que tener en cuenta que la regla @import se evalua en el navegador a la hora de cargar la página, por lo que cada regla @import equivale a una petición al servidor de un nuevo archivo .css</p>
    
    <h3>Formato de @import</h3>
    <p>En principio, existen dos formas de cargar ficheros externos mediante la regla @import: utilizando la función url() o indicando simplemente un  con el archivo o dirección URL:</p>
    <table border="1" witdh="700">
      <tr>
        <th>Formato</th>
        <th>Descripción</th>
      </tr>
      <tr>
        <td>@import url("fichero.css")</td>
        <td>Importa el fichero.css utilizando la función url() de CSS.</td>
      </tr>
      <tr>
        <td>@import "fichero.css"</td>
        <td>Importa el fichero.css utilizando una ruta relativa.</td>
      </tr>
    </table>

    <h3>Importaciones condicionales</h3>
    <p>Dentro de las importaciones que se pueden realizar utilizando la regla @import, existen dos tipos de importaciones condicionales. Por un lado, es posible indicar una media query después de la declaración @import. Esto permite que la hoja de estilos externa se descargue y procese solo si el navegador cumple con las condiciones especificadas en la media query. Por otro lado, se puede combinar la regla @supports con @import para establecer condiciones específicas.</p>
  
    <h3>Import con media queries</h3>
    <p>Permite importar una hoja de estilos solo si se cumple una condición específica, como el tamaño de la pantalla o el tipo de dispositivo. Esto ayuda a optimizar la carga de estilos y mejorar el rendimiento de la página.</p>
  </section>

</body>
</html>